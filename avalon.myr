use std
use json
use sys

const main = {
	std.put("Welcome to Avalon\n")
	match std.dial("tcp!localhost!7777")
	| `std.Err e: std.put("Error connecting to server: {}\n", e)
	| `std.Ok fd: start_client(fd)
	;;
}

type msgid = byte[:]

type all_msg = struct
    msgtype : int
    major   : int
    minor   : int
    recent  : msgid[:]
    root    : msgid
    parent    : msgid
    uuid      : msgid
    content   : byte[:]
    username  : byte[:]
    timestamp : int
;;

type parse_err = byte[:]

// borrowed from libjson
const jstrfmt = {sb, str
	std.sbputs(sb, "\"")
	for c : str
		match (c : char)
		| '\x0c':	std.sbputs(sb, "\\f")
		| '\\':	std.sbputs(sb, "\\\\")
		| '\n': std.sbputs(sb, "\\n")
		| '\r':	std.sbputs(sb, "\\r")
		| '\t': std.sbputs(sb, "\\t")
		| _:	std.sbputb(sb, c)
		;;
	;;
	std.sbputs(sb, "\"")
}

// jsonify converts an all_msg into a json-encoded representation of itself.
// It only support NEW and QUERY message types
const jsonify = {m : all_msg -> byte[:]
	var sb = std.mksb()
        std.sbfmt(sb, "{{\"Type\": {},\"Parent\": \"{}\",\"UUID\": \"{}\",\"Username\": \"{}\",\"Timestamp\": {},\"Content\": ",
        	m.msgtype, m.parent, m.uuid, m.username, m.timestamp)
	jstrfmt(sb, m.content)
	std.sbfmt(sb, "}}\n")
	var s = std.sbfin(sb)
	-> s
}

// unpack a parsed json message into a struct representing its contents
const unpack = {parsed : json.elt# -> std.result(all_msg, parse_err)
	match parsed#
	| `json.Obj pairs :
		var m : all_msg
		for (key, value) : pairs
  			match (key, value#)
  			| ("Type", `json.Num n) : m.msgtype = (n : int)
  			| ("Root", `json.Str s) : m.root = (s : msgid)
  			| ("Parent", `json.Str p) : m.parent = (p : msgid)
  			| ("Content", `json.Str c) : m.content = c
  			| ("Username", `json.Str u) : m.username = u
  			| ("UUID", `json.Str i) : m.uuid = (i : msgid)
  			| ("Major", `json.Num n) : m.major= (n : int)
  			| ("Minor", `json.Num n) : m.minor = (n : int)
  			| ("Timestamp", `json.Num n) : m.timestamp = (n : int)
			| ("Recent", `json.Arr a) :
				var ids : msgid[:] = std.slzalloc(a.len)
				var index = 0
				for &(`json.Str s) : a
                                    ids[index++] = (s : msgid)
        			;;
				m.recent = ids
  			| _ : //todo
  			;;
		;;
        	-> `std.Ok m
	| _ : -> `std.Err ("Invalid protocol message, json root is not an object" : parse_err)
	;;
}

const WelcomeType = 0
const QueryType = 1
const NewType = 2

const start_client = {conn : std.fd
	var pollfiles : sys.pollfd[:] = [
		[ .fd = (conn : sys.fd), .events = sys.Pollin, .revents = 0 ],
        	[ .fd = (std.In: sys.fd), .events = sys.Pollin, .revents = 0 ],
	][:]
	var reply_to = ("" : msgid)
	var reply : all_msg
	std.put("Connected to server!\n")
	while sys.poll(pollfiles, -1) > 0
		// watch the socket
		if pollfiles[0].revents & sys.Pollin > 0
        		match recv_message(conn)
                        | `std.Err e : std.put("Error in recv_message: {}\n", e)
                        | `std.Ok m :
                            match m.msgtype
                            | WelcomeType : reply_to = m.root
                            | QueryType :
                            | NewType : std.put("{}: {}", m.username, m.content)
                                if m.content[m.content.len-1] != ('\n' : byte)
                                    std.put("\n")
                                ;;
                                reply_to = m.uuid
                            | _ :
                            ;;
                        ;;
    		;;
		// watch stdin
		if pollfiles[1].revents & sys.Pollin > 0
			match read_input((pollfiles[1].fd : std.fd))
			| `std.Err _ :
			| `std.Ok msg : 
				reply.content = msg
				reply.parent = reply_to
				reply.msgtype = NewType
				reply.uuid = ("" : msgid)
				reply.username = "avalon"
				reply.timestamp = (std.now() : int)
				match send_message((pollfiles[0].fd : std.fd), reply)
				| `std.Some e : std.put("Error sending message: {}\n", e)
				| _:
				;;
			;;
		;;
	;;
}

const bufsize = 1024

const read_message = {conn : std.fd -> std.result(json.elt#, byte[:])
	var buf : byte[:] = std.slzalloc(bufsize)
	match std.read(conn, buf)
	| `std.Err e:
		var errbuf = std.mksb()
		_ = std.sbfmt(errbuf,"{}", e)
		-> `std.Err std.sbfin(errbuf)
	| `std.Ok n:
		match json.parse(buf[:n])
		| `std.Err err:
        		var errbuf = std.mksb()
        		_ = std.sbfmt(errbuf,"{}", err)
        		-> `std.Err std.sbfin(errbuf)
		| `std.Ok j:
			-> `std.Ok j
		;;
	;;
}

const read_input = {fd : std.fd -> std.result(byte[:], std.errno)
	var buf : byte[:] = std.slzalloc(bufsize)
	match std.read(fd, buf)
	| `std.Err e: -> `std.Err e
	| `std.Ok n:
		if n == bufsize
			std.put("Long message, splitting")
		;;
                -> `std.Ok buf[:n]
	;;
}

const send_message = {fd : std.fd, m : all_msg -> std.option(byte[:])
	var encoded = jsonify(m)
	var written = std.fput(fd, "{}", encoded)
	if written < encoded.len
		-> `std.Some "Failed to write all of message"
	;;
	-> `std.None
}

const recv_message = {fd : std.fd -> std.result(all_msg, byte[:])
    match read_message(fd)
    | `std.Err e: -> `std.Err std.fmt("Error reading message: {}\n", e)
    | `std.Ok j:
        match unpack(j)
        | `std.Err e : -> `std.Err std.fmt("Error unpacking message: {}\n", e)
        | `std.Ok m : -> `std.Ok m
        ;;
    ;;
}
