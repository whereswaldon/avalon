use std
use json
use sys

const main = {
	std.put("Welcome to Avalon\n")
	match std.dial("tcp!localhost!7777")
	| `std.Err e: std.put("Error connecting to server: {}\n", e)
	| `std.Ok fd: start_client(fd)
	;;
}

type msgid = byte[:]

type all_msg = struct
    msgtype : int
    major   : int
    minor   : int
    recent  : msgid[:]
    root    : msgid
    parent    : msgid
    uuid      : msgid
    content   : byte[:]
    username  : byte[:]
    timestamp : int
;;

type parse_err = byte[:]

// unpack a parsed json message into a struct representing its contents
const unpack = {parsed : json.elt# -> std.result(all_msg, parse_err)
	match parsed#
	| `json.Obj pairs :
		var m : all_msg
		for (key, value) : pairs
  			match (key, value#)
  			| ("Type", `json.Num n) : m.msgtype = (n : int)
  			| ("Root", `json.Str s) : m.root = (s : msgid)
  			| ("Parent", `json.Str p) : m.parent = (p : msgid)
  			| ("Content", `json.Str c) : m.content = c
  			| ("Username", `json.Str u) : m.username = u
  			| ("UUID", `json.Str i) : m.uuid = (i : msgid)
  			| ("Major", `json.Num n) : m.major= (n : int)
  			| ("Minor", `json.Num n) : m.minor = (n : int)
  			| ("Timestamp", `json.Num n) : m.timestamp = (n : int)
			| ("Recent", `json.Arr a) :
				var ids : msgid[:] = std.slzalloc(a.len)
				var index = 0
				for &(`json.Str s) : a
                                    ids[index++] = (s : msgid)
        			;;
				m.recent = ids
  			| _ : //todo
  			;;
		;;
        	-> `std.Ok m
	| _ : -> `std.Err ("Invalid protocol message, json root is not an object" : parse_err)
	;;
}

const WelcomeType = 0
const QueryType = 1
const NewType = 2

const start_client = {conn : std.fd
	var pollfiles : sys.pollfd[:] = [
		[ .fd = (conn : sys.fd), .events = sys.Pollin, .revents = 0 ],
        	[ .fd = (std.In: sys.fd), .events = sys.Pollin, .revents = 0 ],
	][:]
	var reply_to : byte[:] = ""
	std.put("Connected to server!\n")
	while sys.poll(pollfiles, -1) > 0
		// watch the socket
		if pollfiles[0].revents & sys.Pollin > 0
        		match read_message(conn)
        		| `std.Err e: std.put("Error reading message: {}\n", e)
        		| `std.Ok j:
				match unpack(j)
				| `std.Err e : std.put("Error unpacking message: {}\n", e)
				| `std.Ok m :
					match m.msgtype
					| WelcomeType :
					| QueryType :
					| NewType : std.put("{}: {}", m.username, m.content)
						if m.content[m.content.len-1] != ('\n' : byte)
							std.put("\n")
						;;
					| _ :
					;;
				;;
        		;;
                ;;
		// watch stdin
		if pollfiles[1].revents & sys.Pollin > 0
			match read_input((pollfiles[1].fd : std.fd))
			| `std.Err _ :
			| `std.Ok msg : std.put("Sending: {}\n", msg)
			;;
		;;
	;;
}

const bufsize = 1024

const read_message = {conn : std.fd -> std.result(json.elt#, byte[:])
	var buf : byte[:] = std.slzalloc(bufsize)
	match std.read(conn, buf)
	| `std.Err e:
		var errbuf = std.mksb()
		_ = std.sbfmt(errbuf,"{}", e)
		-> `std.Err std.sbfin(errbuf)
	| `std.Ok n:
		match json.parse(buf[:n])
		| `std.Err err:
        		var errbuf = std.mksb()
        		_ = std.sbfmt(errbuf,"{}", err)
        		-> `std.Err std.sbfin(errbuf)
		| `std.Ok j:
			-> `std.Ok j
		;;
	;;
}

const read_input = {fd : std.fd -> std.result(byte[:], std.errno)
	var buf : byte[:] = std.slzalloc(bufsize)
	match std.read(fd, buf)
	| `std.Err e: -> `std.Err e
	| `std.Ok n:
		if n == bufsize
			std.put("Long message, splitting")
		;;
                -> `std.Ok buf[:n]
	;;
}
